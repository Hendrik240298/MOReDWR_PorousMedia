# -*- coding: utf-8 -*-
"""FEniCSx_3D_poroelasticity_for_porous_media.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1chuOQdLQcWPYzQSw892FNIRJ1btYH_Iw
"""

import dolfinx

# Scaled variable
mu = 1
rho = 1
beta = 1.25
lambda_ = beta

import numpy as np
import ufl

from mpi4py import MPI
from petsc4py.PETSc import ScalarType

from dolfinx import mesh, fem, plot, io
import dolfinx.fem.petsc

domain = mesh.create_box(MPI.COMM_WORLD, [np.array([-32., -32., 0.]), np.array([32., 32., 64.])],
                  [8,8,8], cell_type=mesh.CellType.tetrahedron) #hexahedron)
V = fem.VectorFunctionSpace(domain, ("CG", 1))

def clamped_boundary(x):
    return np.isclose(x[2], 0)

def compression_boundary(x):
    return np.isclose(x[2], 64.) * (np.abs(x[0]) <= 16.) * (np.abs(x[1]) <= 16.)

def compression_traction(x):
    return np.array([0,0,1. * compression_boundary(x)])

fdim = domain.topology.dim - 1
boundary_facets = mesh.locate_entities_boundary(domain, fdim, clamped_boundary)
compression_boundary_facets = mesh.locate_entities_boundary(domain, fdim, compression_boundary)

facet_indices, facet_markers = [], []
fdim = domain.topology.dim - 1

facets = mesh.locate_entities(domain, fdim, clamped_boundary)
facet_indices.append(facets)
facet_markers.append(np.full_like(facets, 2))

facets = mesh.locate_entities(domain, fdim, compression_boundary)
facet_indices.append(facets)
facet_markers.append(np.full_like(facets, 1))

facet_indices = np.hstack(facet_indices).astype(np.int32)
facet_markers = np.hstack(facet_markers).astype(np.int32)
sorted_facets = np.argsort(facet_indices)
facet_tag = mesh.meshtags(domain, fdim, facet_indices[sorted_facets], facet_markers[sorted_facets])

u_D = np.array([0,0,0], dtype=ScalarType)
bc = fem.dirichletbc(u_D, fem.locate_dofs_topological(V, fdim, boundary_facets), V)


# bc_compression = fem.dirichletbc(np.array([0,0,1], dtype=ScalarType), fem.locate_dofs_topological(V, fdim, compression_boundary_facets), V)
# T_function = fem.Function(V)
# T_function.interpolate(compression_traction)
#fem.petsc.set_bc(T_function, [bc_compression])

T = fem.Constant(domain, ScalarType((0, 0, 1.)))

ds = ufl.Measure("ds", domain=domain)
ds_compression = ufl.Measure("ds", domain=domain, subdomain_data=compression_boundary_facets)


def epsilon(u):
    return ufl.sym(ufl.grad(u)) # Equivalent to 0.5*(ufl.nabla_grad(u) + ufl.nabla_grad(u).T)
def sigma(u):
    return lambda_ * ufl.nabla_div(u) * ufl.Identity(len(u)) + 2*mu*epsilon(u)

u = ufl.TrialFunction(V)
v = ufl.TestFunction(V)
a = ufl.inner(sigma(u), epsilon(v)) * ufl.dx
L = ufl.dot(fem.Constant(domain, ScalarType((0, 0, -1.))), v) * ds(1)

# assemble rhs L to the vector
b = fem.assemble_vector(L)
print(b.array)
#ufl.dot(ScalarType(0,0,T_function), v) * ufl.dx #ds_compression

problem = fem.petsc.LinearProblem(a, L, bcs=[bc], petsc_options={"ksp_type": "preonly", "pc_type": "lu"})
uh = problem.solve()

with io.XDMFFile(domain.comm, "deformation.xdmf", "w") as xdmf:
    xdmf.write_mesh(domain)
    uh.name = "Deformation"
    xdmf.write_function(uh)

